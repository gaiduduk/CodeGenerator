# CodeGenerator 
@author  Гайдук Михаил (Минск 2016г. x29a100@mail.ru vk.com/x29a100 +375255451247)

Генератор кода, для поиска реализаций вычисления числа Пи.

Задача данного класса показать что любое решение задачи можно найти перебором.

Введение:

Даннай метод поиска решения был скопирован с живых организмов, которые используют механизм ДНК.
Он может создавать новые системы и алгоритмы которых ранее не было. Это возможно только с помощью
перебора всех возможных вариантов организмов(программ) которые способны выжить(выполняться).
А так же ДНК имеет возможность к репликации. Данный механизм скрещивает в случайном порядке уже
сгенерированные системы(ООП), что позволяет быстрее и эффективнее создавать большие организмы.

Описание метода генерации кода:

Для тестирования я взял реализацию расчета числа Пи без расчета до точности знака. (см. calculatePiInJavaView)
Чем проще функция тем быстрее её можно найти перебором.
Такой вид функции является простым для человеческого восприятия, но он отличается от машинного представления.
Например одна строка в Java "dx = 1.0 / (i * i);" раскладывается в несколько действий.
А именно на: умножение "(i * i)" и деление "1.0 / x".
Так что в машинном представлении расчет числа Пи будет иметь другой(менее крссивый) вид. (см. calculatePiInMachineView)
    Для того что бы сгенерировать такую функцию необходимо понять что мы в ней видим.
1) Константы
2) Локльные переменные
3) Присваивания
4) Циклы или условные переходы
5) Выполнение операций с параметрами
6) Возвращение результата
    Рассмотрим код(он не имеет смысла но показывает все необходимые конструкции):
int result = 1 + 2;
if (result == 3)
    result += 2;
return result;
    В псевдокоде это буде выглядеть:
1: Создать переменную result. Проинициализировать значением сложения числа 1 и числа 2
2: Если равны result и число 3 то перейти на строку 3, иначе перейти на строку 4
3: Присвоить переменной result значением сложения result и числа 2
4: Вернуть результат result.
    И сдесь мы видим что в данном случае почти все проводимые операции имеют по два параметра.
Но есть варианты где у операции всего один параметр. (Например: return result, Math.sqrt, int result = 1)
В данном случае искуственно добавим пустую операцию что бы у всех строк было по два парамета(return result + 0),
или заменим аналогичной ей операцией с двумя параметрами(Math.sqrt(9) => Math.pow(9, 0.5)).
    Таким образом в каждой строке кода будет операция с двумя параметрами.(см. calculatePiInTableView)
Строки будут иметь формализованный вид:
1) Возвращает ли строка значение
2) К какой переменной присваивается значение
3) Какая операция выполняется
4) Первый параметр операции
5) Второй параметр операции
6) На какую строку перейти если значение текущей равно 1(true)
    Так программу можно предствить в виде матрицы.
Строки которой будут одной строкой кода, а столбцы это параметр каждой конструкции(в последовательности формализации).
    Теперь осталось только перебрать все возможные варианты значений этой таблицы.
Максимальными значениями каждого слобца будут(см. setMaxIndexes):
1) Флаг возвращает ли значение. 2 варианта.
2) Номер строки к которой присваивается значение. Вариантов столько же сколько и строк.
3) Индекс выполняемой операции. Вариантов столько же сколько и фунцкий.
4) Индекс значения первой переменной. Вариантов столько же сколько и строк + количество констант.
5) Индекс значения второй переменной. -//-
6) Номер строки на которую нужно перейти. Вариантов столько же сколько и строк.
Итого реализацию calculatePiInTableView можно представить в виде calculatePIInTable;
    Используя алгоритмы комбинаторики можно объединить одну строку матрицы в большое число.
Например:
Значение переменных:
{1, 0, 2, 3, 4, 0}
Вариантов значений переменных:
{2, 1, 9, 5, 5, 1}
Объединение в одно число(см getIndex):
(1 mod 1) + (0 mod 2) + (2 mod (2*1)) + (3 mod (2*1*9)) + (4 mod (2*1*5)) + (0 mod(2*1*5*5)) = 419
Разбиение на массив(см. getCode):
a[0] = (419 / 1) mod (2*1*9*5*5*1) = 1
a[1] = (419 / (2)) mod (1*9*5*5*1) = 0
a[2] = (419 / (2*1)) mod (9*5*5*1) = 2
a[3] = (419 / (2*1*9)) mod (5*5*1) = 3
a[4] = (419 / (2*1*9*5)) mod (5*1) = 4
a[5] = (419 / (2*1*9*5*5)) mod (1) = 0
Добавление единицы к данному числу будет являться следующей реализацией кода программы.
Таким же способом возможно объединить и идентификаторы каждой строки.
Итого в данном примере может быть (2*1*9*5*5*1) = 450 вариантов алгоритмов.
Теперь просто переберая числа с 0 до 450-1 можно получить тела всех вариантов алгоритмов.
Задача эта трудоемкая, поэтому её нужно разбить на равные части и рассчитывать на нескольких машинах.
Нужно не забывать что существуют вечные циклы, и для предотвращения вечных циклов на выполнение каждому
алгоритму необходимо дать ограниченное число действий. (см. invoke)

Пример работающей программы можно найти в фунции main.

Плюсы данного генератора:
    Простота реализации.
    Большую задачу можно разбить на блоки, и с каждым блоком сложность расчета увеличивается линейно.

Минусы данного генератора:
    Наличие довольно большого количества нерабочих программ.

Возможности:
    Можно распределить задачу генерации на несколько компьютеров.
    Возможно эта программа найдёт неизвестный алгоритм расчета числа Пи. Которй будет работать быстрее
    чем все существующие алгоритмы.
    Возможно изменить операции и константы под любую задачу. Но это гипотетически опасное действие. Так
    как оно может причинить вред выполняемому устройству, иным устройствам или человечеству.
    Можно основываясь на данном методе изменить данный алгоритм для расчета на квантовых компьютерах
    для того что бы скорость генерации была сравнима со скоростью генарции ДНК.

Вдохновило меня, на создание данного генератора, выступление Денни Хиллиса на конференции TED 1994г.
https://www.youtube.com/watch?v=xID7QCCJiXU
Ну и конечно возможный конец света для органических организмов и восстанию роботов :)